<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Ethan McAuliffe's Blog</title>
    <atom:link href="/feed.xml" rel="self" type="application/rss+xml"/>
    <link>http://localhost:4000/</link>
    <description>An assortment of projects I've completed or am working on.</description>
    <pubDate>Wed, 31 Jan 2018 08:55:57 -0500</pubDate>
    
      <item>
        <title>Challenge 2. Rotary Encoder:Gray Code</title>
        <link>/2018/01/20/Gray-Code-Challenge.html</link>
        <guid isPermaLink="true">/2018/01/20/Gray-Code-Challenge.html</guid>
        <description>&lt;h2 id=&quot;purpose&quot;&gt;Purpose&lt;/h2&gt;
&lt;p&gt;The purpose of this project is to take input from the rotary encoder and display its value on three 7-segment displays. The rotary encoder outputs its value in gray code, so it must be converted to a binary value. To display this binary value, it must be converted to a binary-coded-decimal (BCD). Transistors must be used to cycle through the 7-segment displays in order to give the appearance of every display being on at once.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Parts List&lt;/th&gt;
      &lt;th&gt; &lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;4-Bit Gray-Code Rotary Encoder&lt;/td&gt;
      &lt;td&gt;3× 7-Segment Display&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;CD4511BE BCD to 7-Segment Display IC&lt;/td&gt;
      &lt;td&gt;4× 1MΩ Resistor&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;3× 3904 NPN Transistor&lt;/td&gt;
      &lt;td&gt;3× 1kΩ Resistor&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Arduino Uno&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;procedure&quot;&gt;Procedure&lt;/h2&gt;
&lt;p&gt;This challenge started by wiring the rotary encoder to an existing 7-segment BCD display circuit. The initial circuit consisted of a 4511 IC connected to three 7-segment displays. The displays achieved persistence of vision (POV) by toggling the ground connection through the use of NPN transistors. The wiring of the rotary encoder is nearly the same as that in Challenge 1 Rotary Switch Monitor.&lt;/p&gt;

&lt;p&gt;The real difference is in the output from the rotary encoder. Instead of returning a binary number according to the position of the rotor, the encoder used here returns a “Gray code” value. Gray code is very different from binary. Instead of being a “weighted” number system, wherein a change in a specific digit always has the same affect on a number, Gray code is unweighted. This makes it a code instead of a number system. The key feature of Gray code is that between each number only one bit changes value. When using binary, multiple bits often change from a 1 to a 0 while incrementing or decrementing number value. This reduces ambiguity between number states and, in extreme cases, can reduce wear on memory. At right is the bottom view of Gray code rotary encoder, with white squares being zeros and black squares representing ones.&lt;/p&gt;

&lt;p&gt;&lt;img style=&quot;float: right;&quot; src=&quot;https://emcauliffe.ca/Images/ER%20Reports/Grade%2012/Challenge%202.%20Rotary%20Encoder%20Gray%20code/rotaryEncoderGraphic.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;The code does the brunt of the work in this challenge. The code consists of three main parts. First, the program takes input from the rotary encoder attached to &lt;code class=&quot;highlighter-rouge&quot;&gt;PORTD&lt;/code&gt; and converts the Gray code to a binary value. Next, the code converts this to a BCD value on &lt;code class=&quot;highlighter-rouge&quot;&gt;r17&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;r18&lt;/code&gt;. Finally the program displays these values on the 7-segment displays using POV. The code then loops to constantly poll the input states of the rotary encoder. 
In the first step of the input portion, the &lt;code class=&quot;highlighter-rouge&quot;&gt;collect&lt;/code&gt; function stores the input state of &lt;code class=&quot;highlighter-rouge&quot;&gt;PORTD&lt;/code&gt; to a register. It then shifts this register right, as the zero pin of &lt;code class=&quot;highlighter-rouge&quot;&gt;PORTD&lt;/code&gt; does not have input, and the first input is instead on pin one. To convert the Gray code to binary, the &lt;code class=&quot;highlighter-rouge&quot;&gt;convert&lt;/code&gt; function adds the binary value of the gray code input to the value of the x register and stores this in the z register. Next it queries the value stored at this position in memory. Here it returns a binary value equivalent to the Gray code. This is because the register stores the binary conversion of the Gray code at the index of the direct binary value of the gray code. For example, while Gray code &lt;code class=&quot;highlighter-rouge&quot;&gt;0b0011&lt;/code&gt; is a two, the direct binary value is three.&lt;/p&gt;

&lt;p&gt;Next, the program converts the binary value to a BCD. Beginning at the &lt;code class=&quot;highlighter-rouge&quot;&gt;loop&lt;/code&gt; label, the program shifts the input value left through the output registers, carrying the dropped value into each consecutive register. Here the &lt;code class=&quot;highlighter-rouge&quot;&gt;iterate&lt;/code&gt; register decrements, as the algorithm must know whether or not the input number is fully converted or not. Next the program checks if the low bit of the first register is greater than or equal to three. The value of this register increases by three if this condition is true. The &lt;code class=&quot;highlighter-rouge&quot;&gt;tens&lt;/code&gt; label repeats this step for the high bit of the first register. Instead, however, it checks if the register has a value greater than 80 (0x50) and adds 48 (0x30) if this condition is true. Again, this step repeats under the &lt;code class=&quot;highlighter-rouge&quot;&gt;hundreds&lt;/code&gt; label, checking the low bit of the second register and adding three accordingly. Here it jumps back to the &lt;code class=&quot;highlighter-rouge&quot;&gt;loop&lt;/code&gt; label. The input value is fully converted to BCD when the &lt;code class=&quot;highlighter-rouge&quot;&gt;iterate&lt;/code&gt; register reaches zero.&lt;/p&gt;

&lt;p&gt;In the final part, the &lt;code class=&quot;highlighter-rouge&quot;&gt;pov&lt;/code&gt; function takes the registers storing the BCD value and outputs the according number to the 4511 BCD to 7-segment display chip. The hundreds register displays first, with output on &lt;code class=&quot;highlighter-rouge&quot;&gt;PORTC&lt;/code&gt;. Next, the base pin of the according transistor activates by setting &lt;code class=&quot;highlighter-rouge&quot;&gt;PORTB&lt;/code&gt;. After displaying the hundreds digit, the tens digit is displayed by swapping the nibbles of the first register (&lt;code class=&quot;highlighter-rouge&quot;&gt;r17&lt;/code&gt;), and repeating the steps for the hundreds register. The transistor select register shifts by one to enable the tens display and disable the hundreds display. Next, &lt;code class=&quot;highlighter-rouge&quot;&gt;r17&lt;/code&gt; swaps nibbles again and the above steps repeat, but for the ones digit. In the final step, the program jumps to the beginning of the program and the process repeats.&lt;/p&gt;

&lt;h2 id=&quot;media&quot;&gt;Media&lt;/h2&gt;
&lt;table&gt;
  &lt;tr&gt;
    &lt;td&gt;
      &lt;img src=&quot;https://emcauliffe.ca/Images/ER%20Reports/Grade%2012/Challenge%202.%20Rotary%20Encoder%20Gray%20code/challenge2_bb.png&quot; /&gt;
    &lt;/td&gt;
    &lt;td&gt;
      &lt;img src=&quot;https://emcauliffe.ca/Images/ER%20Reports/Grade%2012/Challenge%202.%20Rotary%20Encoder%20Gray%20code/20180116_161909.jpg&quot; /&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;th&gt;Fritzing diagram&lt;/th&gt;
    &lt;th&gt;Circuit overview&lt;/th&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td&gt;
      &lt;img src=&quot;https://emcauliffe.ca/Images/ER%20Reports/Grade%2012/Challenge%202.%20Rotary%20Encoder%20Gray%20code/20180120_161226.jpg&quot; /&gt;
    &lt;/td&gt;
    &lt;td&gt;
      &lt;img src=&quot;https://emcauliffe.ca/Images/ER%20Reports/Grade%2012/Challenge%202.%20Rotary%20Encoder%20Gray%20code/20180120_161906.jpg&quot; /&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;th&gt;Proper operation showing output 14&lt;/th&gt;
    &lt;th&gt;Bottom of rotary encoder&lt;/th&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;th colspan=&quot;2&quot;&gt;Link to YouTube Video: &lt;a href=&quot;https://youtu.be/K7AFz38Lux8&quot;&gt;https://youtu.be/K7AFz38Lux8&lt;/a&gt;&lt;/th&gt;
  &lt;/tr&gt;
&lt;/table&gt;

&lt;h2 id=&quot;code&quot;&gt;Code&lt;/h2&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;; GrayCodeChallenge.asm
;
; Created: 2018-01-15 8:57:57 AM
; Author : Ethan McAuliffe
.def	iterate = r24
.def	temp  = r25
.def	three = r23
.def	threeTens = r22

.cseg

.org 0x0000
   rjmp  reset
;segment table format: ;gfab_cde.

.org 0x0010
grayStart:
  .DB	0,1,3,2,7,6,4,5,15,14,12,13,8,9,11,10
grayEnd:

reset:
	ldi   r16, low(RAMEND)		;ALL assembly code should start by
	out   spl,r16				      ; setting the Stack Pointer to
	ldi   r16, high(RAMEND)		; the end of SRAM to support
	out   sph,r16				      ; function calls, etc.
	ldi   xl,low(grayStart&amp;lt;&amp;lt;1)	;position X and Y pointers to the
	ldi   xh,high(grayStart&amp;lt;&amp;lt;1)	;start and end addresses of
	ldi   yl,low(grayEnd&amp;lt;&amp;lt;1)   ; our data table, respectively
	ldi   yh,high(grayEnd&amp;lt;&amp;lt;1)
	movw  z,x	                 ;start Z pointer off at the start address of the table.

	ldi r16,0x1E
	out DDRD,r16			
	ldi r16,0x07
	out DDRB,r16			;pins to control transistors
	ldi r16,0x0F
	out DDRC,r16			;pins to control 7-segment driver    

collect:
	clr r16
	clr r17
	clr r18
	in r16,PIND			;store input from rotary encoder
	lsr r16			    ;shift right to get gray code
	movw z,r16			;move to element the gray code is in binary
	add zl,xl
	lpm r18,z			  ;store fetched binary value

convert:
	mov r16,r18
	ldi iterate, 8
	ldi three, 0x03
	ldi threeTens, 0x30
	clr r17
	clr r18

loop:
   rol r16
   rol r17
   rol r18				;shift value and BCD registers with carry
   dec iterate			
   breq pov				;jump to POV if there are no bits left to convert

   mov temp, r17					
   andi temp, 0x0F					
   cpi temp, 0x05			
   brlo tens        ;skip to tens if value is less than 5		
   add r17,three    ;otherwise add three
tens:
   cpi temp, 0x50			
   brlo hundreds
   add r17,threeTens
hundreds:
   andi temp, 0x0F
   cpi temp, 0x50			
   brlo loop
   add r18, three
rjmp loop

pov:
	out PORTC,r18			;output hundreds value
	ldi r16,0x04
	out PORTB,r16			;enable hundreds 7-seg disp
	rcall delay
	lsr r16

	swap r17
	out PORTC,r17			;output tens value
	out PORTB,r16			;enable tens 7-seg disp
	rcall delay
	lsr r16

	swap r17
	out PORTC,r17			;output ones value
	out PORTB,r16			;enable ones 7-seg disp
	rcall delay
rjmp collect

delay:
; Generated by delay loop calculator
; at http://www.bretmulvey.com/avrdelay.html
;
; Delay 16 000 cycles
; 1ms at 16 MHz

    ldi  r19, 21
    ldi  r20, 199
L1: dec  r20
    brne L1
    dec  r19
    brne L1
ret
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;To conclude, I am satisfied with the final result of this project. Unfortunately, I was not able to have operational code by the end of the challenge period. After working on my program throughout the week, however, I was able to get a working solution. My initial code was organized properly, but not operational. This challenge has adequately tested my knowledge of assembly code. It has also helped me develop my understanding of Gray code and a broader understanding on conversion algorithms/techniques.&lt;/p&gt;

&lt;h2 id=&quot;reference&quot;&gt;Reference&lt;/h2&gt;
&lt;p&gt;D’Arcy, Chris. “TEI4M Challenges.” ACES, RSGC, 15 Jan. 2018, &lt;a href=&quot;http://darcy.rsgc.on.ca/ACES/TEI4M/1718/Challenges.html#2&quot;&gt;darcy.rsgc.on.ca/ACES/TEI4M/1718/Challenges.html#2&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Grayhill. “Series 25L.” Grayhill.com, Digi-Key, &lt;a href=&quot;http://www.grayhill.com/assets/1/7/Mech_Encoder_25L.pdf&quot;&gt;www.grayhill.com/assets/1/7/Mech_Encoder_25L.pdf&lt;/a&gt;.&lt;/p&gt;
</description>
        <pubDate>Sat, 20 Jan 2018 00:00:00 -0500</pubDate>
      </item>
    
      <item>
        <title>Challenge 2. Rotary Switch Monitor</title>
        <link>/2017/12/02/Rotary-switch-monitor.html</link>
        <guid isPermaLink="true">/2017/12/02/Rotary-switch-monitor.html</guid>
        <description>&lt;h2 id=&quot;purpose&quot;&gt;Purpose&lt;/h2&gt;
&lt;p&gt;The purpose of this challenge is to create a circuit to light up a bicolour LED a specific colour depending on the position of a rotary decoder. The project works by reading the value of a  rotary encoder connected to an ATtiny85, then determining if said number has an odd or even number of set bits and displaying the appropriate colour on the LED. If the number of set bits is even, the LED will show red. Otherwise, it will be green. A resistor network provides appropriate pull down resistors for the input from the rotary encoder. The led should change colour immediately depending on the value of the rotary encoder.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Parts List&lt;/th&gt;
      &lt;th&gt; &lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;ATtiny85&lt;/td&gt;
      &lt;td&gt;Red-Green BiColour LED&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;10 Position BCD Rotary DIP Switch&lt;/td&gt;
      &lt;td&gt;10k Ω Resistor Network (6-Pin Bussed)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Atmel ICE AVR Debugger&lt;/td&gt;
      &lt;td&gt;ATtiny85 ISP Breakout&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;procedure&quot;&gt;Procedure&lt;/h2&gt;
&lt;p&gt;&lt;img style=&quot;float: right&quot; src=&quot;https://emcauliffe.ca/Images/ER%20Reports/Grade%2012/Challenge%201%20Rotary%20Switch%20Monitor/chrome_2017-12-02_14-22-14.png&quot; /&gt;
This challenge started with reading the datasheet for the rotary encoder and wiring the circuit accordingly. Positive voltage connected to the common pin and the binary outputs connected to the resistor network. The resistor network provides a pull down resistance for the outputs of the rotary encoder. These outputs also connected to the input pins of the ATtiny85. Pin 1 connected to &lt;code class=&quot;highlighter-rouge&quot;&gt;PORTB0&lt;/code&gt;, 2 to &lt;code class=&quot;highlighter-rouge&quot;&gt;PORTB1&lt;/code&gt; and 4 to &lt;code class=&quot;highlighter-rouge&quot;&gt;PORTB2&lt;/code&gt;. This meant that the first 3 bits of &lt;code class=&quot;highlighter-rouge&quot;&gt;PORTB&lt;/code&gt; represented the same value as shown on the rotary encoder. At right is the pinout of said rotary encoder. A bicolour LED is also connected to the ATtiny85 on pins &lt;code class=&quot;highlighter-rouge&quot;&gt;PORTB3&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;PORTB4&lt;/code&gt;, where the longer lead is in &lt;code class=&quot;highlighter-rouge&quot;&gt;PORTB3&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The next step was programming the ATtiny85 to read the binary value presented on its pins, determine the number of set bits, and display the appropriate LED colour. The program first enables output on &lt;code class=&quot;highlighter-rouge&quot;&gt;PORTB&lt;/code&gt; pins 2 and 3 in the &lt;code class=&quot;highlighter-rouge&quot;&gt;start&lt;/code&gt; label. Next, the microcontroller imports the high/low values on &lt;code class=&quot;highlighter-rouge&quot;&gt;PORTB&lt;/code&gt; to a register using the &lt;code class=&quot;highlighter-rouge&quot;&gt;in&lt;/code&gt; instruction. An &lt;code class=&quot;highlighter-rouge&quot;&gt;andi&lt;/code&gt; instruction strips the highest 4 bits from this value and each bit is then tested to be either a one or a zero. If the bit is a one, the value on a separate register increases by one. If bit zero of this external register is a zero, the number of set bits is even, and the program jumps to the &lt;code class=&quot;highlighter-rouge&quot;&gt;isEven&lt;/code&gt; label. This label calls the &lt;code class=&quot;highlighter-rouge&quot;&gt;green&lt;/code&gt; function, and then returns to the &lt;code class=&quot;highlighter-rouge&quot;&gt;load&lt;/code&gt; label to ensure constant monitoring of the rotary encoder value. If said value is odd, the same occurs but with the &lt;code class=&quot;highlighter-rouge&quot;&gt;isOdd&lt;/code&gt; label and &lt;code class=&quot;highlighter-rouge&quot;&gt;red&lt;/code&gt; function.&lt;/p&gt;

&lt;h2 id=&quot;media&quot;&gt;Media&lt;/h2&gt;
&lt;table&gt;
  &lt;tr&gt;
    &lt;td&gt;
      &lt;img src=&quot;https://emcauliffe.ca/Images/ER%20Reports/Grade%2012/Challenge%201%20Rotary%20Switch%20Monitor/challenge1.jpg&quot; /&gt;
    &lt;/td&gt;
    &lt;td&gt;
      &lt;img src=&quot;https://emcauliffe.ca/Images/ER%20Reports/Grade%2012/Challenge%201%20Rotary%20Switch%20Monitor/20171201_150546.jpg&quot; /&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;th&gt;3D Render of circuit&lt;/th&gt;
    &lt;th&gt;Photo of circuit&lt;/th&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td&gt;
      &lt;img src=&quot;https://emcauliffe.ca/Images/ER%20Reports/Grade%2012/Challenge%201%20Rotary%20Switch%20Monitor/RotarySwitch10.JPG&quot; /&gt;
    &lt;/td&gt;
    &lt;td&gt;
      &lt;img src=&quot;https://emcauliffe.ca/Images/ER%20Reports/Grade%2012/Challenge%201%20Rotary%20Switch%20Monitor/fritzing_bb.png&quot; /&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;th&gt;Rotary encoder used in circuit&lt;/th&gt;
    &lt;th&gt;Fritzing Diagram&lt;/th&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;th colspan=&quot;2&quot;&gt;Link to YouTube Video: &lt;a href=&quot;https://youtu.be/-HsjXjVvNDY&quot;&gt;https://youtu.be/-HsjXjVvNDY&lt;/a&gt;&lt;/th&gt;
  &lt;/tr&gt;
&lt;/table&gt;

&lt;h2 id=&quot;code&quot;&gt;Code&lt;/h2&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;; Challenge 1.asm
; Created: 2017-12-01 1:58:44 PM
; Author : Ethan McAuliffe

#define TEST_BIT 0b00001111
; Replace with your application code
start:
	ldi r16,0x18
	out 0x17,r16
	clr r16

load:
	clr r16
	in r16,0x16

again:
	andi r16,0x0F
	mov r18,r16		;copy
	ldi r17,11		;mask
	and r18,r17		;test
	sbrc r18,0
	inc r19
	asr r16
	brne again
sbrc r19, 0
rjmp isOdd
rjmp isEven

isOdd:
	rcall red
	rjmp load

isEven:
	rcall green
	rjmp load

green:
	ldi r16,0x10
	out 0x18,r16
	ret

red:
	ldi r16,0x08
	out 0x18,r16
	ret
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;To conclude, I am somewhat disappointed with the result of this project. While I was able to complete the code for the project in the allotted time, I did not get as many photos as I should and was not able to record any video of its operation. While my 3D render animation is effective at displaying what a similar circuit would look like, I would rather have video that I could use to explain the fundamental workings of my project. Furthermore, my code has switched up the colour of the LED to be displayed; when the number of set bits are even, my code sets the LED green LED instead of red. I did, however, find the challenge to be quite enjoyable. I liked being pushed to delve deep into the ATtiny85 datasheet and AVR instruction set. I do believe that I learned a lot from the completion of this challenge.&lt;/p&gt;

&lt;h2 id=&quot;reference&quot;&gt;Reference&lt;/h2&gt;
&lt;p&gt;Atmel Corporation. Atmel ATtiny25, ATtiny45, ATtiny85 Datasheet. Aug. 2013, &lt;a href=&quot;http://www.atmel.com/images/atmel-2586-avr-8-bit-microcontroller-attiny25-attiny45-attiny85_datasheet.pdf&quot;&gt;www.atmel.com/images/atmel-2586-avr-8-bit-microcontroller-attiny25-attiny45-attiny85_datasheet.pdf&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Wurth Electronics Inc. “428527420910 Drawing.” Digi-Key, 25 July 2014, &lt;a href=&quot;http://katalog.we-online.de/em/datasheet/428527420910.pdf&quot;&gt;katalog.we-online.de/em/datasheet/428527420910.pdf&lt;/a&gt;.&lt;/p&gt;
</description>
        <pubDate>Sat, 02 Dec 2017 00:00:00 -0500</pubDate>
      </item>
    
      <item>
        <title>Short ISP:Relay Logic Adder</title>
        <link>/2017/11/05/Short-ISP.html</link>
        <guid isPermaLink="true">/2017/11/05/Short-ISP.html</guid>
        <description>&lt;h2 id=&quot;purpose&quot;&gt;Purpose&lt;/h2&gt;
&lt;p&gt;The purpose of this project is to gain a better understanding of how relays work and how early computer logic was able to use relays before the invention of transistors. The end product also aims to be simple and easy to operate for potential students and their parents touring the Design Engineering Studio (DES). Finally, the end product aims to sound pleasing to the ear by performing a series of satisfying mechanical clicks when operated.&lt;/p&gt;

&lt;p&gt;The adder is to combine the sum of nine inputs, each of which being a power of two, into a binary output. The maximum sum value is 31. The calculator is capable of producing a possible 32 (2&lt;sup&gt;5&lt;/sup&gt;) unique sums (where zero is an acceptable sum). Each switch will add either a 2, 4, 6 or 8 to the total.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Parts List&lt;/th&gt;
      &lt;th&gt; &lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;4× Full Adder Custom PCB&lt;/td&gt;
      &lt;td&gt;5× DC Power Jack&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;9× SPDT Toggle Switch&lt;/td&gt;
      &lt;td&gt;4× DC Barrel Plug&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;20W (5V@4A) Power Supply&lt;/td&gt;
      &lt;td&gt;5× 10mm Red LED&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;80× DPDT 5V 2A DC Relay&lt;/td&gt;
      &lt;td&gt;Grey PLA 3D Printer Filament&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;6.5” of 1”×1” Square Acrylic tubing&lt;/td&gt;
      &lt;td&gt;Clear Acrylic Sheet&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;24× Male/Female Pin Headers&lt;/td&gt;
      &lt;td&gt;Plywood Board&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;procedure&quot;&gt;Procedure&lt;/h2&gt;
&lt;p&gt;This project started with choosing relays to be a component in the project through a class Yankee Swap. The planning and idea brainstorming came after choosing relays to be a main component. After researching historic use of relays as logic capable devices, the chosen project would be a modular full adder circuit.&lt;/p&gt;

&lt;p&gt;Testing and research on creating logic gates with relays, specifically the NAND logic gate, proceeded the planned idea. NAND gates are important for logic operations as they can create any of the other logic gates when organized in specific ways. This testing and planning is similar to Project 2. Digital (Transistor-Based) Logic Gates, but with relays instead of transistors.&lt;/p&gt;

&lt;p&gt;&lt;img style=&quot;float:right&quot; src=&quot;https://emcauliffe.ca/Images/ER%20Reports/Grade%2012/Short%20ISP/Screen%20Shot%202017-11-05%20at%2017.05.12.png&quot; /&gt;
The next step was creating a half adder with NAND logic using relays. The half adder is a circuit which takes two separate inputs and returns a sum, in binary, of those outputs on two pins, the SUM (Σ) and CARRY OUT pins. For example, if both outputs are high, the sum is a decimal two, represented by a low output on the Σ pin (as there are zero groups of 20) and a high output on the CARRY OUT pin (as there is one group of 21). After testing this circuit and reproducing it in EAGLE, the circuit needed further modifications to transform it into a full adder. Accomplishing this consists of chaining two half adder circuits together and performing a logical OR on the two CARRY OUT pins. The chaining of half adders works by connecting the Σ pin of the first half adder to an input on the second and adding a CARRY IN pin which connects to the second input of the second half adder. Now that a CARRY IN pin is present, the circuit is an operational full adder and it is possible to chain it with other identical full adders to work as a calculator (that only does addition).  &lt;/p&gt;

&lt;p&gt;The design and fabrication of a custom PCB followed the creation of a full adder circuit diagram in EAGLE (PCB shown right, link to schematic image: &lt;a href=&quot;https://goo.gl/cXBRqa&quot;&gt;https://goo.gl/cXBRqa&lt;/a&gt;). The next step, after the arrival of the PCBs, was soldering the components to the board and testing operation. This includes soldering yellow relays in such a way that the four boards together spell out the word “ACES”.&lt;/p&gt;

&lt;p&gt;&lt;img style=&quot;float:right&quot; src=&quot;https://emcauliffe.ca/Images/ER%20Reports/Grade%2012/Short%20ISP/LED_Display.jpg&quot; /&gt;
The next step was designing the LED holder (present below at right) and the clips used to mount the PCBs. Using Fusion 360 for design and the Ultimaker 3 for fabrication made this easy and efficient. This step included multiple iterations of the PCB clip design. The final product has an aesthetically pleasing symmetry, is easy to use and is strong.&lt;/p&gt;

&lt;p&gt;&lt;img style=&quot;float:right&quot; src=&quot;https://emcauliffe.ca/Images/ER%20Reports/Grade%2012/Short%20ISP/RelayInternals.jpg&quot; /&gt;
The next step is attaching the parts to the plywood board with the intention of making the final project both visually appealing and easy to use. This step consists of gluing the PCBs down using the custom designed clips and drilling holes through to the other side of the board to hide wires. It also includes soldering switches to power rails, chaining the CARRY OUT and CARRY IN pins of consecutive boards together, connecting the LEDs to the outputs of the full adder PCBs and labeling specific components for ease of use. The final step is connecting the full adder PCBs to the respective switch inputs. The project is now complete.&lt;/p&gt;

&lt;h2 id=&quot;media&quot;&gt;Media&lt;/h2&gt;
&lt;table&gt;
  &lt;tr&gt;
    &lt;td&gt;
      &lt;img src=&quot;https://emcauliffe.ca/Images/ER%20Reports/Grade%2012/Short%20ISP/render1.png&quot; /&gt;
    &lt;/td&gt;
    &lt;td&gt;
      &lt;img src=&quot;https://emcauliffe.ca/Images/ER%20Reports/Grade%2012/Short%20ISP/20171026_234541.jpg&quot; /&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;th&gt;Circuit board render with clips&lt;/th&gt;
    &lt;th&gt;Yellow relays soldered on boards A &amp;amp; C&lt;/th&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td&gt;
      &lt;img src=&quot;https://emcauliffe.ca/Images/ER%20Reports/Grade%2012/Short%20ISP/DSC_0019.JPG&quot; /&gt;
    &lt;/td&gt;
    &lt;td&gt;
      &lt;img src=&quot;https://emcauliffe.ca/Images/ER%20Reports/Grade%2012/Short%20ISP/DSC_0021.JPG&quot; /&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;th&gt;Final Product&lt;/th&gt;
    &lt;th&gt;Output showing value of &quot;11&quot;&lt;/th&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;th colspan=&quot;2&quot;&gt;Link to YouTube Video: &lt;a href=&quot;https://youtu.be/ibXhrRucC1A&quot;&gt;https://youtu.be/ibXhrRucC1A&lt;/a&gt;&lt;/th&gt;
  &lt;/tr&gt;
&lt;/table&gt;

&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;In conclusion, I am happy with the result of this project. I enjoyed working with relays, despite them not being my initial choice in the Yankee Swap. This project had the unique benefit of being a mini history lesson too. I learned, through research online, how relays used to be found in nearly all electronics prior to the widespread use of vacuum tubes and transistors. Through this project I also learned why relays are never used in logic applications anymore: they use a lot of power, are very expensive and are at risk of mechanical failure. I am also happy with the appearance of my final project and am happy that it is going to be displayed in the lab for potential and younger students to get excited about electronics. While there are many skills that this project did not require (coding being the most significant), I still believe that this project was a resounding success.&lt;/p&gt;

&lt;h2 id=&quot;reference&quot;&gt;Reference&lt;/h2&gt;
&lt;p&gt;Lekule, Sostenes. “A Full-Adder.” LEKULE BLOG, 21 Apr. 2015, &lt;a href=&quot;http://sosteneslekule.blogspot.ca/2015/04/a-full-adder.html&quot;&gt;http://sosteneslekule.blogspot.ca/2015/04/a-full-adder.html&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;“Relay Logic Gates.” Electro-Tech-Online.com, &lt;a href=&quot;http://www.electro-tech-online.com/attachments/upload_2015-6-18_21-28-8-png.92993/&quot;&gt;http://www.electro-tech-online.com/attachments/upload_2015-6-18_21-28-8-png.92993/&lt;/a&gt;.&lt;/p&gt;
</description>
        <pubDate>Sun, 05 Nov 2017 00:00:00 -0400</pubDate>
      </item>
    
      <item>
        <title>Medium ISP:Word Clock and Weather Predictor</title>
        <link>/2017/05/22/Medium-ISP.html</link>
        <guid isPermaLink="true">/2017/05/22/Medium-ISP.html</guid>
        <description>&lt;h2 id=&quot;purpose&quot;&gt;Purpose&lt;/h2&gt;
&lt;p&gt;The purpose of this project is to create a clock capable of showing the current time, temperature, humidity and short-term forecast in a clean, sleek way. The clock is to read the time off of an Real Time Clock (RTC) IC, read air pressure, humidity and temperature wirelessly from a separate device, and display everything in an easy to understand way. To display the time, words for each five minute interval and each hour are to illuminate. To display the current temperature and relative humidity percentage (%RH), the first ten columns are to light up and show the required digits, similar to a 7-segment display. A “C” and a “%” sign will also illuminate for temperature and %RH respectively. The weather sensor is to be separate from the clock and communicate with the main clock via a NRF24L01+ wireless communication IC.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Parts List&lt;/th&gt;
      &lt;th&gt; &lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;2× Arduino Uno&lt;/td&gt;
      &lt;td&gt;2× NRF24L01+ Wireless Chip&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;93× Red-Green BiColour LEDs&lt;/td&gt;
      &lt;td&gt;4’×2’ Medium Density Fibreboard (MDF)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Clear Acrylic Sheet&lt;/td&gt;
      &lt;td&gt;Piano Black Plastic Sheet&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;BME280 I2C or SPI Temperature Humidity Pressure Sensor&lt;/td&gt;
      &lt;td&gt;DS1307 I2C Real Time Clock&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;procedure&quot;&gt;Procedure&lt;/h2&gt;
&lt;p&gt;&lt;img style=&quot;float:right&quot; src=&quot;https://emcauliffe.ca/Images/ER%20Reports/Grade%2011/Medium%20ISP/chrome_2017-05-22_14-23-26.png&quot; /&gt;
This project begins with designing the main clock face. It is paramount that the clock face contains all the necessary words to display any five minute interval of time. This step also requires careful planning of the order that words will appear to ensure readability (top to bottom, left to right) and that there is adequate spacing between each word. Each line must also have the same number of characters, and the “C” and “%” characters must be present only in the far-right column. Creation of the design initially began in a text file, and was then transferred to a table in a word document to add colour. Creation of the final design required using a CAD program, in this case ViaCAD 3D, to ensure proper spacing of characters. Mr. Elia helped greatly with this. The final step in designing the clock face was sending the design files off to be laser cut in acrylic and plastic. Assembly began when the laser cut pieces arrived. Gluing the characters  into place meant ensuring that the block shape of each was clear acrylic, and the inner “floating” parts of the characters were the same black plastic as the rest of the clock face. This allowed for avoiding a stencil font while still maintaining readability. &lt;/p&gt;

&lt;p&gt;Creating the wireless weather sensor was the next step. This began with reading the datasheet to understand where to find data on the IC and how to access it using Serial Peripheral Interface (SPI). Pictured on the previous page is the pinout for the BME280 sensor. It is a surface mount device.&lt;/p&gt;

&lt;p&gt;SPI works similar to serial communication, but with the added benefit of the slave device (in this case the BME280 sensor) being able to contact the master device as well (in this case the Arduino Uno). Unlike I2C, it requires 4 pins. See Wireless Communication: Temperature Data Logging for more information on Serial Communication. SPI is the chosen protocol in this case because it means using only one communication protocol to interact with the wireless transmitter and the weather sensor.&lt;/p&gt;

&lt;p&gt;Configuring the BME280 chip is important so that that reports the values as desired. The &lt;code class=&quot;highlighter-rouge&quot;&gt;sensorConfig() &lt;/code&gt; function configures the sensor by performing a reset, identifying how often the sensor is to record information, and how sensitive the sensor should be to sudden changes in values. It also initiates &lt;code class=&quot;highlighter-rouge&quot;&gt;getCompensationData()&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The data from the BME280 chip requires processing before it can accurately display the time. This is because each individual chip has different sensitivities to the environment. The manufacturer, Bosch, solves this problem by storing “compensation data” in specific registers on the chip. The &lt;code class=&quot;highlighter-rouge&quot;&gt;getCompensationData()&lt;/code&gt; function in the Remote Sensor code obtains this data. The &lt;code class=&quot;highlighter-rouge&quot;&gt;getCompensationData()&lt;/code&gt; function is only called once as the compensation data never changes. A special &lt;code class=&quot;highlighter-rouge&quot;&gt;struct&lt;/code&gt; called &lt;code class=&quot;highlighter-rouge&quot;&gt;compData&lt;/code&gt; stores this data because some values have different lengths, some are “signed” and some are “unsigned”. This was problematic as the datasheet provided incorrect information on which characters were signed or unsigned. by comparing the individual compensation data readouts to those of the Adafruit library, it was easy to deduce which were incorrect.&lt;/p&gt;

&lt;p&gt;Signed characters use format called &lt;em&gt;Two’s Compliment&lt;/em&gt; to store their values. Using an 8-bit byte as an example, two’s compliment has the ability to store a value ranging from -128 to 127 inclusive. Two’s compliment works by accepting a positive integer from 0-128, then performing a bitwise “NOT”, and adding 1. This value now represents a negative integer. The computer can tell that the value is negative, because the most significant bit of binary integer is a “1”. For more information on bitwise, see the BiColour LED Matrix project.&lt;/p&gt;

&lt;p&gt;Recording the uncompensated, or “raw”, data from the sensor happens after reading the compensation data. The &lt;code class=&quot;highlighter-rouge&quot;&gt;getRawData()&lt;/code&gt; function obtains said data and stores it in a &lt;code class=&quot;highlighter-rouge&quot;&gt;struct&lt;/code&gt; called &lt;code class=&quot;highlighter-rouge&quot;&gt;rawData&lt;/code&gt;. This data is then run through specific algorithms defined in the datasheet, which use the compensation data recorded earlier, to get the temperature in degrees Celsius, the pressure in Pascals, and the relative humidity percentage. These algorithms are &lt;code class=&quot;highlighter-rouge&quot;&gt;temp()&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;pressure()&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;humidity()&lt;/code&gt; for temperature, pressure and humidity respectively. Each returns a value of specific size for easy formatting and transmission using the &lt;code class=&quot;highlighter-rouge&quot;&gt;transmit()&lt;/code&gt; function.&lt;/p&gt;

&lt;p&gt;The &lt;code class=&quot;highlighter-rouge&quot;&gt;transmit()&lt;/code&gt; function compacts the temperature, pressure and humidity data into one unsigned, 64-bit integer, and transmits it wirelessly via the NRF24L01+. The program then uses the &lt;code class=&quot;highlighter-rouge&quot;&gt;deepSleep()&lt;/code&gt; function to enter the peripherals into low power mode, wait, and then turn the sensor back on. This function uses SPI to write to a specific register on the BME280 sensor requesting that it enter sleep mode.&lt;/p&gt;

&lt;p&gt;The clock code first uses I2C to intercept the current hour and minute from the DS1307 RTC. This code is works almost identically to that used in the Nixie Tube Clock project. The &lt;code class=&quot;highlighter-rouge&quot;&gt;updateTime()&lt;/code&gt; function obtains this time and stores it in a &lt;code class=&quot;highlighter-rouge&quot;&gt;struct&lt;/code&gt; called &lt;code class=&quot;highlighter-rouge&quot;&gt;currentTime&lt;/code&gt; for easy access. This function also converts the 24-hour time stored on the RTC into 12-hour time for the clock to display.&lt;/p&gt;

&lt;p&gt;The &lt;code class=&quot;highlighter-rouge&quot;&gt;receive()&lt;/code&gt; function then looks for available data from the remote sensor, formats the recieved 64 bit, unsigned integer into temperature, pressure and humidity again, and then stores it in a &lt;code class=&quot;highlighter-rouge&quot;&gt;struct&lt;/code&gt; called &lt;code class=&quot;highlighter-rouge&quot;&gt;senseData&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The current time is then formatted into specific words and printed to the serial monitor via the &lt;code class=&quot;highlighter-rouge&quot;&gt;printTimeAndData()&lt;/code&gt; function. This function first reads the current minute and maps it to a value from 0-12, inclusive. This value is then used to query the &lt;code class=&quot;highlighter-rouge&quot;&gt;minuteText[]&lt;/code&gt; array and determine what text to show for the current minute. Next the function determines if the clock should display “TO” or “PAST” the hour. The clock only switches to “TO” after 35 minutes of the current hour have elapsed. The mapped value is again used to determine this. The final step in showing the current time is displaying the appropriate hour in relation to the current time. For this the current hour value minus one (because arrays are zero indexed) index of &lt;code class=&quot;highlighter-rouge&quot;&gt;thehourText[]&lt;/code&gt; array prints to the serial monitor. If the minutes, however, are greater than 35, the clock must display the future hour as the clock will now show “TO” instead of “PAST”. As such the index of the current hour is directly indexed into the &lt;code class=&quot;highlighter-rouge&quot;&gt;hourText[]&lt;/code&gt; array. Finally the function prints the data intercepted from the remote sensor to the serial monitor. This includes whether or not the weather is improving, or worsening.&lt;/p&gt;

&lt;p&gt;The &lt;code class=&quot;highlighter-rouge&quot;&gt;isWeatherImproving()&lt;/code&gt; function uses an average of the pressure from each five minute interval over the past hour plus the current pressure and compares it against the oldest pressure reading. If the average is less than the oldest reading, pressure is decreasing  and the weather is getting worse. Otherwise, the weather is improving and the function returns &lt;code class=&quot;highlighter-rouge&quot;&gt;true&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;While simple at first, numerous obstacles faced the construction of this clock later on. Cutting the perfectly square back plate of the clock and wooden borders of the face plate was the first step. Gluing the cardstock baffles which ensured no light bleed from neighbouring characters followed. This ensured that the clock would be easy to read. Problems arose in the final steps when planning out a NeoPixel LED matrix for backlighting, as the NeoPixels were non-functional. BiColour Red/Green LEDs replaced the NeoPixels after a last-minute visit to a hardware store. Unfortunately, however, the ATmega328P does not have enough ports to control the 93 LED matrix, and as such, the clock cannot function. Painting the clock and gluing the faceplate in position were the final steps. A possible solution to this problem would be a larger Arduino device to control the entire matrix, or (the better option) to purchase a working strip of NeoPixels.&lt;/p&gt;

&lt;h2 id=&quot;media&quot;&gt;Media&lt;/h2&gt;
&lt;table&gt;
  &lt;tr&gt;
    &lt;td&gt;
      &lt;img src=&quot;https://emcauliffe.ca/Images/ER%20Reports/Grade%2011/Medium%20ISP/DSC_0034.jpg&quot; /&gt;
    &lt;/td&gt;
    &lt;td&gt;
      &lt;img src=&quot;https://emcauliffe.ca/Images/ER%20Reports/Grade%2011/Medium%20ISP/DSC_0036.jpg&quot; /&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;th&gt;Drilling holes for LEDs&lt;/th&gt;
    &lt;th&gt;Soldering LED matrix&lt;/th&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td&gt;
      &lt;img src=&quot;https://emcauliffe.ca/Images/ER%20Reports/Grade%2011/Medium%20ISP/DSC_0031.jpg&quot; /&gt;
    &lt;/td&gt;
    &lt;td&gt;
      &lt;img src=&quot;https://emcauliffe.ca/Images/ER%20Reports/Grade%2011/Medium%20ISP/DSC_0042.jpg&quot; /&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;th&gt;Testing Main clock module without matrix&lt;/th&gt;
    &lt;th&gt;Illuminated Clock Face&lt;/th&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;th colspan=&quot;2&quot;&gt;Link to YouTube Video: &lt;a href=&quot;https://youtu.be/0zP5Rlmc7oA&quot;&gt;https://youtu.be/0zP5Rlmc7oA&lt;/a&gt;&lt;/th&gt;
  &lt;/tr&gt;
&lt;/table&gt;

&lt;h2 id=&quot;code&quot;&gt;Code&lt;/h2&gt;
&lt;h3 id=&quot;main-clock-code&quot;&gt;Main Clock Code&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;Wire.h&amp;gt;
#include &amp;lt;nRF24L01.h&amp;gt;
#include &amp;lt;printf.h&amp;gt;
#include &amp;lt;RF24.h&amp;gt;
#include &amp;lt;RF24_config.h&amp;gt;

#define RTC_ADDRESS 0x68

RF24 radio(9, 10);
uint8_t addresses[][6] = {&quot;3g8wM&quot;, &quot;0Us9x&quot;};
uint64_t data;
bool goodWeather;
String hourText[] = {&quot;ONE&quot;, &quot;TWO&quot;, &quot;THREE&quot;, &quot;FOUR&quot;, &quot;FIVE&quot;, &quot;SIX&quot;, &quot;SEVEN&quot;, &quot;EIGHT&quot;, &quot;NINE&quot;, &quot;TEN&quot;, &quot;ELEVEN&quot;, &quot;TWELVE&quot;};
String minuteText[] = {&quot;&quot;, &quot;FIVE&quot;, &quot;TEN&quot;, &quot;A QUARTER&quot;, &quot;TWENTY&quot;, &quot;TWENTY FIVE&quot;, &quot;A HALF&quot;, &quot;TWENTY FIVE&quot;, &quot;TWENTY&quot;, &quot;A QUARTER&quot;, &quot;TEN&quot;, &quot;FIVE&quot;, &quot;&quot;};
uint32_t pressureAverage[13];
uint8_t durationThroughHour;

struct SENSORDATA {
  int8_t temp;
  float pressure;
  uint8_t hum;
};

struct CURRENT_TIME {
  uint8_t hours;
  uint8_t minutes;
};

SENSORDATA senseData;
CURRENT_TIME currentTime;

void setup() {
  Serial.begin(9600);
  radio.begin();
  Wire.begin();

  radio.setChannel(99);

  radio.openReadingPipe(1, addresses[0]);
  radio.startListening();
}

void loop() {
  updateTime();
  receive();
  printTimeAndData();
}

void receive() {
  if (radio.available()) {
    radio.read(&amp;amp;data, sizeof(uint64_t));
    senseData.temp = (int8_t)(data &amp;gt;&amp;gt; 40);
    senseData.pressure = ((data &amp;gt;&amp;gt; 8) &amp;amp; 0xFFFFFFFF) / 25600.00;
    senseData.hum = (uint8_t)data &amp;amp; 0xFF;
    pressureAverage[durationThroughHour] = (uint32_t)senseData.pressure;
  }
}

void updateTime() {
  Wire.beginTransmission(RTC_ADDRESS);
  Wire.write(1); //prepare rtc to be read from
  Wire.endTransmission();
  Wire.requestFrom(RTC_ADDRESS, 7);
  while (!Wire.available());
  currentTime.minutes =  readTime(Wire.read() &amp;amp; 0x7f); //minute
  uint8_t hours = readTime(Wire.read() &amp;amp; 0x3f);
  if (hours &amp;gt; 12) {
    hours = hours - 12;
  }
  if (hours == 0) {
    hours == 12;
  }
  currentTime.hours = hours;
}

bool isWeatherImproving() {
  uint32_t pressureSum;
  for (uint8_t ii; ii &amp;lt; 13; ii++) {
    pressureSum += pressureAverage[ii];
  }
  if (pressureSum / 13 &amp;gt; (pressureAverage[12 - durationThroughHour])) {
    return false;
  } else {
    return true;
  }
}

void printTimeAndData() {
  Serial.print(&quot;It is &quot;);
  durationThroughHour = map(currentTime.minutes, 0, 60, 0, 12);
  Serial.print(minuteText[durationThroughHour]);
  if (durationThroughHour != 0) {
    if (durationThroughHour &amp;lt;= 6) {
      Serial.print(&quot; PAST &quot;);
    } else {
      Serial.print(&quot; TO &quot;);
    }
  }
  if (currentTime.minutes &amp;lt; 35) {
    Serial.print(hourText[currentTime.hours - 1]);
    Serial.print(&quot; &quot;);
  } else {
    Serial.print(hourText[currentTime.hours]);
    Serial.print(&quot; &quot;);
  }
  Serial.print(&quot;  --  &quot;);
  Serial.print(senseData.temp);
  Serial.print(&quot;* C &quot;);
  Serial.print(senseData.pressure);
  Serial.print(&quot; hPa &quot;);
  Serial.print(senseData.hum);
  Serial.print(&quot;% RH &quot;);
  if (isWeatherImproving() == true) {
    Serial.print(&quot;IMPROVING &quot;);
  } else {
    Serial.print(&quot;GETTING WORSE &quot;);
  }
  Serial.println();
}

uint8_t readTime(uint8_t input) { //makes time human readable (0-60 and 0-24)
  return ((input / 16 * 10) + (input % 16));
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h3 id=&quot;remote-sensor-code&quot;&gt;Remote Sensor Code&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;SPI.h&amp;gt; // for interfacing with the data sensor
#include &amp;lt;nRF24L01.h&amp;gt;
#include &amp;lt;printf.h&amp;gt;
#include &amp;lt;RF24.h&amp;gt;
#include &amp;lt;RF24_config.h&amp;gt;

#define SENSORSS 10
#define SENSORSPEED 500000

RF24 radio(7, 8);
uint8_t addresses[][6] = {&quot;3g8wM&quot;, &quot;0Us9x&quot;};
int32_t currentTemp;

struct SCOMP {
  uint16_t T1;
  int16_t T2;
  int16_t T3;
  uint16_t P1;
  int16_t P2;
  uint16_t P3;
  uint16_t P4;
  int16_t P5;
  int16_t P6;
  uint16_t P7;
  int16_t P8;
  uint16_t P9;
  uint8_t H1;
  int16_t H2;
  uint8_t H3;
  int16_t H4;
  int16_t H5;
  int8_t H6;
};
struct RAWDATA {
  uint32_t uPress;
  uint32_t uTemp;
  uint32_t uHum;
};

RAWDATA rawRead;
SCOMP compData;

void setup() {
  pinMode(SENSORSS, OUTPUT);
  digitalWrite(SENSORSS, HIGH);

  radio.begin();
  SPI.begin();

  ACSR = B10000000;
  ADCSRA = ADCSRA &amp;amp; B01111111;
  DIDR0 = DIDR0 | B00111111;

  radio.setPALevel(RF24_PA_MAX);
  radio.setChannel(99);
  radio.openWritingPipe(addresses[0]);

  sensorConfig();
}

void loop() {
  getRawData();
  transmit(temp(rawRead.uTemp), pressure(rawRead.uPress), humidity(rawRead.uHum));
  deepSleep();
}

int8_t temp(int32_t inTemp) {//returns temp in degrees celcius int8_t
  int32_t var1, var2;
  var1 = ((((inTemp &amp;gt;&amp;gt; 3) - ((int32_t)compData.T1 &amp;lt;&amp;lt; 1))) * ((int32_t)compData.T2)) &amp;gt;&amp;gt; 11;
  var2 = (((((inTemp &amp;gt;&amp;gt; 4) - ((int32_t)compData.T1)) * ((inTemp &amp;gt;&amp;gt; 4) - ((int32_t)compData.T1))) &amp;gt;&amp;gt; 12) * ((int32_t)compData.T3)) &amp;gt;&amp;gt; 14;
  currentTemp = var1 + var2;
  return round(((currentTemp * 5 + 128) &amp;gt;&amp;gt; 8) / 100.00);
}

int32_t pressure(int32_t inPress) {//returns pressure in int_32
  temp(rawRead.uTemp);
  int64_t var1, var2, p;
  var1 = ((int64_t)currentTemp) - 128000;
  var2 = var1 * var1 * (int64_t)compData.P6;
  var2 = var2 + ((var1 * (int64_t)compData.P5) &amp;lt;&amp;lt; 17);
  var2 = var2 + (((int64_t)compData.P4) &amp;lt;&amp;lt; 35);
  var1 = ((var1 * var1 * (int64_t)compData.P3) &amp;gt;&amp;gt; 8) + ((var1 * (int64_t)compData.P2) &amp;lt;&amp;lt; 12);
  var1 = (((((int64_t)1) &amp;lt;&amp;lt; 47) + var1)) * ((int64_t)compData.P1) &amp;gt;&amp;gt; 33;

  if (var1 == 0) {
    return (uint32_t)0; // avoid exception caused by division by zero
  }

  p = 1048576 - inPress;
  p = (((p &amp;lt;&amp;lt; 31) - var2) * 3125) / var1;
  var1 = (((int64_t)compData.P9) * (p &amp;gt;&amp;gt; 13) * (p &amp;gt;&amp;gt; 13)) &amp;gt;&amp;gt; 25;
  var2 = (((int64_t)compData.P8) * p) &amp;gt;&amp;gt; 19;
  p = ((p + var1 + var2) &amp;gt;&amp;gt; 8) + (((int64_t)compData.P7) &amp;lt;&amp;lt; 4);
  return (uint32_t)p;
}

uint8_t humidity(uint32_t inHum) {//returns percent relative humidity int8_t
  int32_t v1;
  v1 = (currentTemp - ((int32_t)76800));
  v1 = (((((inHum &amp;lt;&amp;lt; 14) - (((int32_t)compData.H4) &amp;lt;&amp;lt; 20) - (((int32_t)compData.H5) * v1)) + ((int32_t)16384)) &amp;gt;&amp;gt; 15) * (((((((v1 * ((int32_t)compData.H6)) &amp;gt;&amp;gt; 10) * (((v1 * ((int32_t)compData.H3)) &amp;gt;&amp;gt; 11) + ((int32_t)32768))) &amp;gt;&amp;gt; 10) + ((int32_t)2097152)) * ((int32_t)compData.H2) + 8192) &amp;gt;&amp;gt; 14));
  v1 = (v1 - (((((v1 &amp;gt;&amp;gt; 15) * (v1 &amp;gt;&amp;gt; 15)) &amp;gt;&amp;gt; 7) * ((int32_t)compData.H1)) &amp;gt;&amp;gt; 4));
  v1 = (v1 &amp;lt; 0) ? 0 : v1;
  v1 = (v1 &amp;gt; 419430400) ? 419430400 : v1;
  return round((v1 &amp;gt;&amp;gt; 12) / 1024.00);
}

void sensorConfig() {
  digitalWrite(SENSORSS, LOW);
  SPI.beginTransaction(SPISettings(SENSORSPEED, MSBFIRST, SPI_MODE0));
  SPI.transfer(0x60);//initiate write to reset register
  SPI.transfer(0xB6);//performs soft reset
  delay(25);
  SPI.endTransaction();
  digitalWrite(SENSORSS, LOW);
  SPI.beginTransaction(SPISettings(SENSORSPEED, MSBFIRST, SPI_MODE0));
  SPI.transfer(0x75);//initiate write to config
  SPI.transfer(0x04);//0.5ms delay, filter x2
  SPI.transfer(0x72);//initiate write to ctrl_hum
  SPI.transfer(0x01);//set filtering to 1x
  SPI.transfer(0x74);//initiate write to ctrl_meas
  SPI.transfer(0xB7);//normal mode
  digitalWrite(SENSORSS, HIGH);
  SPI.endTransaction();
  delay(25);
  getCompensationData();
}

void getRawData() {
  SPI.beginTransaction(SPISettings(SENSORSPEED, MSBFIRST, SPI_MODE0));
  digitalWrite(SENSORSS, LOW);
  SPI.transfer(0xF7);
  //pressure
  rawRead.uPress = SPI.transfer(0x00);
  rawRead.uPress &amp;lt;&amp;lt;= 8;
  rawRead.uPress |= SPI.transfer(0x00);
  rawRead.uPress &amp;lt;&amp;lt;= 8;
  rawRead.uPress |= SPI.transfer(0x00);
  rawRead.uPress &amp;gt;&amp;gt;= 4;
  //temperature
  rawRead.uTemp = SPI.transfer(0x00);
  rawRead.uTemp &amp;lt;&amp;lt;= 8;
  rawRead.uTemp |= SPI.transfer(0x00);
  rawRead.uTemp &amp;lt;&amp;lt;= 8;
  rawRead.uTemp |= SPI.transfer(0x00);
  rawRead.uTemp &amp;gt;&amp;gt;= 4;
  //humidity
  rawRead.uHum = SPI.transfer(0x00);
  rawRead.uHum &amp;lt;&amp;lt;= 8;
  rawRead.uHum |= SPI.transfer(0x00);
  SPI.endTransaction();
  digitalWrite(SENSORSS, HIGH);
}

void transmit(int8_t tempD, uint32_t pressD, uint8_t humD) { //sends data to the main clock
  uint64_t transmissionData;
  transmissionData = tempD;
  transmissionData &amp;lt;&amp;lt;= 32;
  transmissionData |= pressD;
  transmissionData &amp;lt;&amp;lt;= 8;
  transmissionData |= humD;

  radio.powerUp();
  delay(6);
  radio.write(&amp;amp;transmissionData, sizeof(uint64_t));
}

void wakeSensor() {
  digitalWrite(SENSORSS, LOW);
  SPI.beginTransaction(SPISettings(SENSORSPEED, MSBFIRST, SPI_MODE0));
  SPI.transfer(0x74);
  SPI.transfer(0xB7);
  delay(30);
  digitalWrite(SENSORSS, HIGH);
  SPI.endTransaction();
}

void sensorSleep() {
  digitalWrite(SENSORSS, LOW);
  SPI.beginTransaction(SPISettings(SENSORSPEED, MSBFIRST, SPI_MODE0));
  SPI.transfer(0x74);
  SPI.transfer(0xB4);
  delay(30);
  digitalWrite(SENSORSS, HIGH);
  SPI.endTransaction();
}

void deepSleep() { //powers down peripherals and ATmega328
  sensorSleep();
  radio.powerDown();
  delay(20000);
  wakeSensor();
}

void getCompensationData() {//populates compData struct
  digitalWrite(SENSORSS, LOW);
  SPI.beginTransaction(SPISettings(SENSORSPEED, MSBFIRST, SPI_MODE0));
  SPI.transfer(0x88);
  //Temperature
  compData.T1 = (SPI.transfer(0x00) &amp;lt;&amp;lt; 8 | SPI.transfer(0x00));
  compData.T1 = (compData.T1 &amp;gt;&amp;gt; 8 | compData.T1 &amp;lt;&amp;lt; 8);
  compData.T2 = (SPI.transfer(0x00) &amp;lt;&amp;lt; 8 | SPI.transfer(0x00));
  compData.T2 = (compData.T2 &amp;gt;&amp;gt; 8 | compData.T2 &amp;lt;&amp;lt; 8);
  compData.T3 = (SPI.transfer(0x00) &amp;lt;&amp;lt; 8 | SPI.transfer(0x00));
  compData.T3 = (compData.T3 &amp;gt;&amp;gt; 8 | compData.T3 &amp;lt;&amp;lt; 8);
  //Pressure
  compData.P1 = (SPI.transfer(0x00) &amp;lt;&amp;lt; 8 | SPI.transfer(0x00));
  compData.P1 = (compData.P1 &amp;gt;&amp;gt; 8 | compData.P1 &amp;lt;&amp;lt; 8);
  compData.P2 = (SPI.transfer(0x00) &amp;lt;&amp;lt; 8 | SPI.transfer(0x00));
  compData.P2 = (compData.P2 &amp;gt;&amp;gt; 8 | compData.P2 &amp;lt;&amp;lt; 8);
  compData.P3 = (SPI.transfer(0x00) &amp;lt;&amp;lt; 8 | SPI.transfer(0x00));
  compData.P3 = (compData.P3 &amp;gt;&amp;gt; 8 | compData.P3 &amp;lt;&amp;lt; 8);
  compData.P4 = (SPI.transfer(0x00) &amp;lt;&amp;lt; 8 | SPI.transfer(0x00));
  compData.P4 = (compData.P4 &amp;gt;&amp;gt; 8 | compData.P4 &amp;lt;&amp;lt; 8);
  compData.P5 = (SPI.transfer(0x00) &amp;lt;&amp;lt; 8 | SPI.transfer(0x00));
  compData.P5 = (compData.P5 &amp;gt;&amp;gt; 8 | compData.P5 &amp;lt;&amp;lt; 8);
  compData.P6 = (SPI.transfer(0x00) &amp;lt;&amp;lt; 8 | SPI.transfer(0x00));
  compData.P6 = (compData.P6 &amp;gt;&amp;gt; 8 | compData.P6 &amp;lt;&amp;lt; 8);
  compData.P7 = (SPI.transfer(0x00) &amp;lt;&amp;lt; 8 | SPI.transfer(0x00));
  compData.P7 = (compData.P7 &amp;gt;&amp;gt; 8 | compData.P7 &amp;lt;&amp;lt; 8);
  compData.P8 = (SPI.transfer(0x00) &amp;lt;&amp;lt; 8 | SPI.transfer(0x00));
  compData.P8 = (compData.P8 &amp;gt;&amp;gt; 8 | compData.P8 &amp;lt;&amp;lt; 8);
  compData.P9 = (SPI.transfer(0x00) &amp;lt;&amp;lt; 8 | SPI.transfer(0x00));
  compData.P9 = (compData.P9 &amp;gt;&amp;gt; 8 | compData.P9 &amp;lt;&amp;lt; 8);
  //Humidity
  digitalWrite(SENSORSS, HIGH);
  digitalWrite(SENSORSS, LOW);
  SPI.transfer(0xA1);
  compData.H1 = SPI.transfer(0x00);
  digitalWrite(SENSORSS, HIGH);
  digitalWrite(SENSORSS, LOW);
  SPI.transfer(0xE1);
  compData.H2 = (SPI.transfer(0x00) &amp;lt;&amp;lt; 8 | SPI.transfer(0x00));
  compData.H2 = (compData.H2 &amp;gt;&amp;gt; 8 | compData.H2 &amp;lt;&amp;lt; 8);
  compData.H3 = SPI.transfer(0x00);
  compData.H4 = (SPI.transfer(0x00) &amp;lt;&amp;lt; 4) | (SPI.transfer(0x00) &amp;amp; 0xF);
  digitalWrite(SENSORSS, HIGH);
  digitalWrite(SENSORSS, LOW);
  SPI.transfer(0xE5);
  compData.H5 = (SPI.transfer(0x00) &amp;gt;&amp;gt; 4) | (SPI.transfer(0x00) &amp;lt;&amp;lt; 4);
  compData.H6 = SPI.transfer(0x00);
  digitalWrite(SENSORSS, HIGH);
  SPI.endTransaction();
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;In conclusion, this project was unsuccessful; however, it can be easily completed given the correct, fully operational, parts. I did enjoy working with ViaCAD to create a clean, accurate final product, and while it may not work as intended, it does look quite nice. This project taught me to &lt;em&gt;always&lt;/em&gt; test your components before you leave the lab for a long weekend. While I am wholeheartedly disappointed with the results this far, I am optimistic that I can get this project to achieve its intended purpose. While it was quite difficult, I enjoyed working with only the SPI library to communicate with the BME280 chip as it taught me more about the SPI protocol, how data is stored in peripherals, and how to read (and find issues with) datasheets. I have alerted Bosch of the issue with their datasheet and they have yet alerted me of a change. From the issue with the NeoPixels, I learned how to think quickly and produce a final project with some resemblance to the intended final product. I hope to bring what I learned about communication protocols, sensors, data compensation algorithms and limitations of certain products with me for utilization in future projects.&lt;/p&gt;

&lt;h2 id=&quot;reference&quot;&gt;Reference&lt;/h2&gt;
&lt;p&gt;“BME280.” Bosch Sensortec, Bosch, 26 Oct. 2015, &lt;a href=&quot;http://ae-bst.resource.bosch.com/media/_tech/media/datasheets/BST-BME280_DS001-11.pdf&quot;&gt;http://ae-bst.resource.bosch.com/media/_tech/media/datasheets/BST-BME280_DS001-11.pdf&lt;/a&gt;. Accessed 22 May 2017.&lt;/p&gt;

&lt;p&gt;Burgess, Phillip. “Adafruit NeoPixel Überguide.” Adafruit NeoPixel Überguide, Adafruit, 30 Aug. 2013, &lt;a href=&quot;http://learn.adafruit.com/adafruit-neopixel-uberguide/overview&quot;&gt;http://learn.adafruit.com/adafruit-neopixel-uberguide/overview&lt;/a&gt;. Accessed 22 May 2017.&lt;/p&gt;
</description>
        <pubDate>Mon, 22 May 2017 00:00:00 -0400</pubDate>
      </item>
    
      <item>
        <title>Short ISP:Nixie Tube Clock</title>
        <link>/2017/02/04/Short-ISP-Nixie-Clock.html</link>
        <guid isPermaLink="true">/2017/02/04/Short-ISP-Nixie-Clock.html</guid>
        <description>&lt;h2 id=&quot;purpose&quot;&gt;Purpose&lt;/h2&gt;
&lt;p&gt;The purpose of this project is to create a clock that displays the current time, in a 24h format, on 4 nixie tubes. The clock is to show the accurate time, despite power loss, and have only one power supply.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Parts List&lt;/th&gt;
      &lt;th&gt; &lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;ATmega328P&lt;/td&gt;
      &lt;td&gt;16MHz Crystal Oscillator&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;2× 22pF Capacitor&lt;/td&gt;
      &lt;td&gt;680pF Capacitor&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;2× 1nF Capacitor&lt;/td&gt;
      &lt;td&gt;10nF Capacitor&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;2.2µF@250V Capacitor&lt;/td&gt;
      &lt;td&gt;220µF Capacitor&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;19× 10KΩ Resistor&lt;/td&gt;
      &lt;td&gt;4× 47KΩ Resistor&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;680KΩ Resistor&lt;/td&gt;
      &lt;td&gt;1KΩ Resistor&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;0.22Ω@2W Resistor&lt;/td&gt;
      &lt;td&gt;4.3KΩ Resistor&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;2.5KΩ Potentiometer&lt;/td&gt;
      &lt;td&gt;1N4148 Diode&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;MUR1100 Diode&lt;/td&gt;
      &lt;td&gt;BC556 PNP Transistor&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;IRF840 N-Channel MOSFET&lt;/td&gt;
      &lt;td&gt;150µH@3A Inductor&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;MC34063 Switching Regulator&lt;/td&gt;
      &lt;td&gt;Chronodot I2C RTC&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;2× SN74HC595 Shift Register&lt;/td&gt;
      &lt;td&gt;4× K155ID1 BCD Converter&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;4× IN-14 Nixie Tubes&lt;/td&gt;
      &lt;td&gt;Slide Switch&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;7805 5V Voltage Regulator&lt;/td&gt;
      &lt;td&gt;DC Power Jack&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;9V Power Supply&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;procedure&quot;&gt;Procedure&lt;/h2&gt;
&lt;p&gt;This ISP began as an idea while completing the 555 Boost converter circuit. Next, the idea developed a true project with the purchase of nixie tubes and BCD chips on eBay. The creation of a possible schematic occurred as the parts were in the mail. The schematic in question contained a boost converter circuit as well as the nixie tube and driver circuitry. The boost converter in the original circuit was not successful as the capacitors inside the MOSFET interfered with the PWM signal of the ATmega328P and fried it. Next was building a 555 boost converter, which increased voltage to desired levels, but could not sustain load. Instead, an eBay boost converter specifically designed for nixie tubes was purchased.&lt;/p&gt;

&lt;p&gt;Code writing started as soon as the nixie tubes and BCD chips arrived. The programming of the chronodot started the adventure into coding a clock. First, the code calls the hex data for the current hour minute and second from the chronodot using the &lt;code class=&quot;highlighter-rouge&quot;&gt;Wire.read()&lt;/code&gt; function.
The &lt;code class=&quot;highlighter-rouge&quot;&gt;readTime&lt;/code&gt; function formats this data into a human-readable decimal value. Next, the decimal values get fed into the &lt;code class=&quot;highlighter-rouge&quot;&gt;timeData&lt;/code&gt; function. This function takes the decimal values and, using the &lt;code class=&quot;highlighter-rouge&quot;&gt;toNibble&lt;/code&gt; function, creates a 16 digit long string of 1s and 0s. Each digit in the string represents an output on the shift register and each group of 4 digits, or binary nibble, represents a digit on the clock. The &lt;code class=&quot;highlighter-rouge&quot;&gt;toNibble&lt;/code&gt; function takes the binary value of a digit and creates a string exactly 4 digits long.&lt;/p&gt;

&lt;p&gt;After formatting the current time in a way that the shift registers and BCD chips can read, the &lt;code class=&quot;highlighter-rouge&quot;&gt;shiftTime&lt;/code&gt; function sends this data out. The &lt;code class=&quot;highlighter-rouge&quot;&gt;shiftTime&lt;/code&gt; function runs through an entire string and sends the corresponding data to the shift registers.&lt;/p&gt;

&lt;p&gt;Shift registers use 3 pins to receive information from a device like the ATMega 328P. These pins are the serial data, serial clock and latch pins. The shift register indexes a “1” in its memory when the serial data pin is high and, after that, the serial clock pin is high. If the serial data pin is low and the serial clock pin has been set to high, the shift register indexes a “0”. Finally, after receiving all the desired data, the latch pin is set high and the outputs of the shift register change to reflect the data received. The &lt;code class=&quot;highlighter-rouge&quot;&gt;shiftTime&lt;/code&gt; function reads the string of 1s and 0s representing the current time and sends this data to the shift registers.&lt;/p&gt;

&lt;p&gt;&lt;img style=&quot;float:right&quot; src=&quot;https://emcauliffe.ca/Images/ER%20Reports/Grade%2011/Short%20ISP/20170124_161046.jpg&quot; /&gt;&lt;/p&gt;

&lt;p&gt;These shift registers connect to К155ИД1 (K155ID1) binary to decimal converter chips. These chips take the binary nibble and ground the appropriate output pins. The pins ground incoming current because they are specially designed for ИН-14 (IN-14) nixie tubes, which have a common anode.&lt;/p&gt;

&lt;p&gt;Nixie tubes work by lighting a filament inside a glass chamber filled with gas. This gas often consists of neon and some mercury or argon. They need 150V-170V to run and can run off AC or DC. The digits are completely separate from each other and, as such, multiple digits can appear concurrently as in the picture to the right. These specific tubes were manufactured in the USSR and used as numerical displays before the invention of the 7 segment layout.&lt;/p&gt;

&lt;p&gt;The final additions to the code were a daylight savings time switch and the &lt;code class=&quot;highlighter-rouge&quot;&gt;cycleTubes&lt;/code&gt; function. The DST switch allows for a user to efficiently move the hour forward and back on demand. The &lt;code class=&quot;highlighter-rouge&quot;&gt;cycleTubes&lt;/code&gt; function gets called every hour, on the hour, to prevent cathode poisoning on the nixie tubes. Cathode poisoning occurs when a digit is on for a prolonged period of time. The coating on this digit sprays onto nearby digits resulting in dimmer patches and less clear numbers. Cycling through all the possible displays once an hour, prevents this.&lt;/p&gt;

&lt;p&gt;The final addition was the boost converter to power the nixies. Each tube was individually tested for operation and connected to the circuit. A 47KΩ resistor placed on the anodes of each tube to prevents high current from frying the BCD chips. The addition of a 5V voltage regulator allowed the logical components and the nixies to share the same singular power source. The clock was now complete.&lt;/p&gt;

&lt;h2 id=&quot;media&quot;&gt;Media&lt;/h2&gt;
&lt;table&gt;
  &lt;tr&gt;
    &lt;td&gt;
      &lt;img src=&quot;https://emcauliffe.ca/Images/ER%20Reports/Grade%2011/Short%20ISP/20170124_160911.jpg&quot; /&gt;
    &lt;/td&gt;
    &lt;td&gt;
      &lt;img src=&quot;https://emcauliffe.ca/Images/ER%20Reports/Grade%2011/Short%20ISP/20170120_200540.jpg&quot; /&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;th&gt;Demonstrating the layering of digits on a Nixie Tube. &quot;6&quot; is illuminated here.&lt;/th&gt;
    &lt;th&gt;130V-170V DC Boost Converter Circuit&lt;/th&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td&gt;
      &lt;img src=&quot;https://emcauliffe.ca/Images/ER%20Reports/Grade%2011/Short%20ISP/20170202_131447.jpg&quot; /&gt;
    &lt;/td&gt;
    &lt;td&gt;
      &lt;img src=&quot;https://emcauliffe.ca/Images/ER%20Reports/Grade%2011/Short%20ISP/20170203_181132.jpg&quot; /&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;th&gt;Accurate time displaying on the clock&lt;/th&gt;
    &lt;th&gt;Nixie tubes at night&lt;/th&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;th colspan=&quot;2&quot;&gt;Link to YouTube Video: &lt;a href=&quot;https://youtu.be/cuN6FGU5eqE&quot;&gt;https://youtu.be/cuN6FGU5eqE&lt;/a&gt;&lt;/th&gt;
  &lt;/tr&gt;
&lt;/table&gt;

&lt;h2 id=&quot;code&quot;&gt;Code&lt;/h2&gt;
&lt;h3 id=&quot;main-clock-code&quot;&gt;Main Clock Code&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//Name: Ethan McAuliffe
//Date: 2016-12-17
//Project: Nixie Tube Clock
//Status: Functional and Tested

//Libraries
#include &amp;lt;Wire.h&amp;gt;

//Constants
#define serial 2
#define latch 3
#define clk 4
#define DSTPin 9
#define rtc 0x68

//Variables
String currentTime; // current time formatted for the shift registers
int8_t daylight; //daylight savings offset
uint8_t cHour; //current hour
uint8_t cMinute; //current minute
uint8_t cSecond;  //current second

void setup() {
  Wire.begin();

  pinMode(serial, OUTPUT);
  pinMode(latch, OUTPUT);
  pinMode(clk, OUTPUT);

  pinMode(DSTPin, INPUT_PULLUP);
}

void loop() {
  //Interface with the RTC
  Wire.beginTransmission(rtc);
  Wire.write(0); //prepare rtc to be read from
  Wire.endTransmission();
  Wire.requestFrom(rtc, 7);
  while (Wire.available() == 0);
  //read current  minute and hour
  cSecond = readTime(Wire.read());//second
  cMinute = readTime(Wire.read() &amp;amp; 0x7f); //minute
  cHour = readTime(Wire.read() &amp;amp; 0x3f); //hour

  //if the daylight savings time switch is on, add add 1 hour to the current time
  digitalRead(DSTPin) == LOW ? (cHour == 23 ? daylight = -23 : daylight = 1) : daylight = 0;

  //takes current time and sends it to the shift registers
  currentTime = timeData(cHour + daylight, cMinute); // current time binary data. Each nibble represents a digit.
  shiftTime(serial, latch, clk, currentTime); //send current time to the shift registers

  //cycles nixie tubes every hour that they are on
  if (cMinute == 0 &amp;amp;&amp;amp; cSecond == 0) {
    cycleTubes();
  }
}

//Functions
String timeData(uint8_t h, uint8_t m) { //takes the current time and outputs the required data for shift register
  String minutesOnes = toNibble(String((m % 10), BIN));//converts ones digit to binary nibble
  String minutesTens = toNibble(String((m / 10 % 10), BIN));//converts tens digit to binary nibble
  String hoursOnes = toNibble(String((h % 10), BIN));
  String hoursTens = toNibble(String((h / 10 % 10), BIN));

  //output a string of the all binary nibbles for each digit in the time
  String output = hoursTens + hoursOnes + minutesTens + minutesOnes;
  return output;
}

String toNibble (String input) { //converts binary character string to a binary nibble
  String output = input;
  uint8_t lngth = output.length();
  for (uint8_t i = lngth; i &amp;lt; 4; i++) { //adds zeros before binary value until there is a whole nibble
    output = &quot;0&quot; + output;
  }
  return output;
}

void shiftTime (uint8_t serialPin, uint8_t latchPin, uint8_t clockPin, String inputTime) { //sends a binary string to shift registers
  digitalWrite(latchPin, LOW);//set latch pin low to prepare for data to be sent
  for (int8_t i = inputTime.length() - 1; i &amp;gt; -1; i--) { //iterates over entire length of input string
    byte currentChar = inputTime.charAt(i);//gets character &quot;i&quot; in the binary string
    if (currentChar == '1') { //if character is a one send a high signal to the shift registers
      digitalWrite(serialPin, HIGH);
      digitalWrite(clockPin, HIGH);
      digitalWrite(clockPin, LOW);
      digitalWrite(serialPin, LOW);
    } else { //if character is a zero send a low signal
      digitalWrite(serialPin, LOW);
      digitalWrite(clockPin, HIGH);
      digitalWrite(clockPin, LOW);
    }
  }
  digitalWrite(latchPin, HIGH);//lock in data on shift register
}

void cycleTubes () {//cycle all of the digits in unison to prevent cathode poisioning
  for (uint16_t i = 0; i &amp;lt; 1000; i++) {
    uint8_t cycleDigits = ((i % 10) * 10) + i % 10;
    String cycleData = timeData(cycleDigits, cycleDigits);
    shiftTime(serial, latch, clk, cycleData);
    delay(i / 15 + 1);
  }
}

uint8_t readTime (uint8_t input) { //makes time human readable (0-60 and 0-24)
  return ((input / 16 * 10) + (input % 16));
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;In conclusion, I found this project to be quite enjoyable and informative. I enjoyed working with even higher voltages than my previous project, despite being shocked more than a few times. It was fun to learn how to use niche devices to create a device that we use multiple times a day. I also learned some electronic history by reading up on nixie tubes and why they were used. I fully intend to extend this project further and create a custom circuit board using EAGLE as well as designing an enclosure using ViaCAD. I also intend to finally decode the mystery of boost converters (although I believe I know where I went wrong). I put an immense amount of time into this project, but I do not believe that any of it was wasted. I am very much satisfied with my final product.&lt;/p&gt;

&lt;h2 id=&quot;reference&quot;&gt;Reference&lt;/h2&gt;
&lt;p&gt;Alberto. “ATMEGA328 &amp;amp; Arduino Pinout Diagram.” PighiXXX, 18 Feb. 2013, &lt;a href=&quot;http://v.gd/miZ3gY&quot;&gt;http://v.gd/miZ3gY&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Boxall, John. “Using DS1307 and DS3231 Real-Time Clock Modules with Arduino.” Tronixstuff, Tronixlabs, 1 Dec. 2014, &lt;a href=&quot;http://tronixstuff.com/2014/12/01/tutorial-using-ds1307-and-ds3231-real-time-clock-modules-with-arduino/&quot;&gt;http://tronixstuff.com/2014/12/01/tutorial-using-ds1307-and-ds3231-real-time-clock-modules-with-arduino/&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Harrison, Mike. “Nixie Power Supply.” Mike’s Electric Stuff, &lt;a href=&quot;http://www.electricstuff.co.uk/nixpsu.html&quot;&gt;http://www.electricstuff.co.uk/nixpsu.html&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;“IN-14 (ИН-14) Datasheet.” TubeHobby, Gazotron, &lt;a href=&quot;http://tubehobby.com/datasheets/in14.pdf&quot;&gt;http://tubehobby.com/datasheets/in14.pdf&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;“K155ID1 (К155ИД1) Datasheet.” TubeHobby, CCCP, &lt;a href=&quot;http://tubehobby.com/datasheets/k155id1.pdf&quot;&gt;http://tubehobby.com/datasheets/k155id1.pdf&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Onno. “Neon Nostalgia.” Neon Nostalgia, 20 Oct. 2000, &lt;a href=&quot;http://www.glowbug.nl/neon/index.html&quot;&gt;http://www.glowbug.nl/neon/index.html&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Urbach, Claus-Dieter. “FAQ Nixietubes.” NixieClocks.de, &lt;a href=&quot;http://www.nixieclocks.de/FAQ_Nixietubes.pdf&quot;&gt;http://www.nixieclocks.de/FAQ_Nixietubes.pdf&lt;/a&gt;.&lt;/p&gt;
</description>
        <pubDate>Sat, 04 Feb 2017 00:00:00 -0500</pubDate>
      </item>
    
  </channel>
</rss>
