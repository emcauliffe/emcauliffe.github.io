<!DOCTYPE html>
<html class="no-js">
  <head>
	<meta charset="utf-8">
	<title>Search | Blog</title>
	<meta name="description" content="A website with blog posts and pages">
	<meta name="viewport" content="width=device-width, initial-scale=1">

	<!-- CSS -->
	<link rel="stylesheet" href="/assets/css/main.css">

	<!--Favicon-->
	<link rel="shortcut icon" href="/assets/favicon.ico" type="image/x-icon">

	<!-- Canonical -->
	<link rel="canonical" href="/search.html">

	<!-- RSS -->
	<link rel="alternate" type="application/atom+xml" title="Blog" href="/feed.xml" />

	<!-- Font Awesome -->
	<link href="//maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">

	<!-- Google Fonts -->
	
	<link href="//fonts.googleapis.com/css?family=Source+Sans+Pro:400,700,700italic,400italic" rel="stylesheet" type="text/css">
	

	<!-- KaTeX -->
	
	<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/KaTeX/0.8.3/katex.min.css">
	<script src="//cdnjs.cloudflare.com/ajax/libs/KaTeX/0.8.3/katex.min.js"></script>
	

	<!-- Google Analytics -->
	
</head>

  <body>
    <header class="site-header">
	<div class="branding">
		
		<h1 class="site-title">
			<a href="/">Blog</a>
		</h1>
	</div>
	<nav class="site-nav">
		<ul>
			<!--
			
			
			
			
			<li>
				<a class="page-link" href="/about/">
					About
				</a>
			</li>
			
			
			
			
			
			
			
			
			
			
			
			<li>
				<a class="page-link" href="/tags.html">
					tags
				</a>
			</li>
			
			
		-->
			<!-- Social icons from Font Awesome, if enabled  -->
			










































            <!-- Search bar -->
            
		</ul>
	</nav>

</header>

    <div class="content">
      <article >
  <header style="background-image: url('/')">
    <h1 class="title">Search</h1>
    
  </header>
  <section class="post-content"><div class="search">
    <div id="search-results"></div>
    <p id="not-found" style="display: none">
        No results found.
    </p>
</div>


<script>
  window.store = {
    
      "2018-01-20-gray-code-challenge-html": {
        "title": "Challenge 2. Rotary Encoder:Gray Code",
        "tags": "ER, ACES, Grade 12",
        "date": "January 20, 2018",
        "author": "",
        "category": "",
        "content": "PurposeThe purpose of this project is to take input from the rotary encoder and display its value on three 7-segment displays. The rotary encoder outputs its value in gray code, so it must be converted to a binary value. To display this binary value, it must be converted to a binary-coded-decimal (BCD). Transistors must be used to cycle through the 7-segment displays in order to give the appearance of every display being on at once.            Parts List                         4-Bit Gray-Code Rotary Encoder      3× 7-Segment Display              CD4511BE BCD to 7-Segment Display IC      4× 1MΩ Resistor              3× 3904 NPN Transistor      3× 1kΩ Resistor              Arduino Uno             ProcedureThis challenge started by wiring the rotary encoder to an existing 7-segment BCD display circuit. The initial circuit consisted of a 4511 IC connected to three 7-segment displays. The displays achieved persistence of vision (POV) by toggling the ground connection through the use of NPN transistors. The wiring of the rotary encoder is nearly the same as that in Challenge 1 Rotary Switch Monitor.The real difference is in the output from the rotary encoder. Instead of returning a binary number according to the position of the rotor, the encoder used here returns a “Gray code” value. Gray code is very different from binary. Instead of being a “weighted” number system, wherein a change in a specific digit always has the same affect on a number, Gray code is unweighted. This makes it a code instead of a number system. The key feature of Gray code is that between each number only one bit changes value. When using binary, multiple bits often change from a 1 to a 0 while incrementing or decrementing number value. This reduces ambiguity between number states and, in extreme cases, can reduce wear on memory. At right is the bottom view of Gray code rotary encoder, with white squares being zeros and black squares representing ones.The code does the brunt of the work in this challenge. The code consists of three main parts. First, the program takes input from the rotary encoder attached to PORTD and converts the Gray code to a binary value. Next, the code converts this to a BCD value on r17 and r18. Finally the program displays these values on the 7-segment displays using POV. The code then loops to constantly poll the input states of the rotary encoder. In the first step of the input portion, the collect function stores the input state of PORTD to a register. It then shifts this register right, as the zero pin of PORTD does not have input, and the first input is instead on pin one. To convert the Gray code to binary, the convert function adds the binary value of the gray code input to the value of the x register and stores this in the z register. Next it queries the value stored at this position in memory. Here it returns a binary value equivalent to the Gray code. This is because the register stores the binary conversion of the Gray code at the index of the direct binary value of the gray code. For example, while Gray code 0b0011 is a two, the direct binary value is three.Next, the program converts the binary value to a BCD. Beginning at the loop label, the program shifts the input value left through the output registers, carrying the dropped value into each consecutive register. Here the iterate register decrements, as the algorithm must know whether or not the input number is fully converted or not. Next the program checks if the low bit of the first register is greater than or equal to three. The value of this register increases by three if this condition is true. The tens label repeats this step for the high bit of the first register. Instead, however, it checks if the register has a value greater than 80 (0x50) and adds 48 (0x30) if this condition is true. Again, this step repeats under the hundreds label, checking the low bit of the second register and adding three accordingly. Here it jumps back to the loop label. The input value is fully converted to BCD when the iterate register reaches zero.In the final part, the pov function takes the registers storing the BCD value and outputs the according number to the 4511 BCD to 7-segment display chip. The hundreds register displays first, with output on PORTC. Next, the base pin of the according transistor activates by setting PORTB. After displaying the hundreds digit, the tens digit is displayed by swapping the nibbles of the first register (r17), and repeating the steps for the hundreds register. The transistor select register shifts by one to enable the tens display and disable the hundreds display. Next, r17 swaps nibbles again and the above steps repeat, but for the ones digit. In the final step, the program jumps to the beginning of the program and the process repeats.Media                                      Fritzing diagram    Circuit overview                                        Proper operation showing output 14    Bottom of rotary encoder        Link to YouTube Video: https://youtu.be/K7AFz38Lux8  Code; GrayCodeChallenge.asm;; Created: 2018-01-15 8:57:57 AM; Author : Ethan McAuliffe.def\titerate = r24.def\ttemp  = r25.def\tthree = r23.def\tthreeTens = r22.cseg.org 0x0000   rjmp  reset;segment table format: ;gfab_cde..org 0x0010grayStart:  .DB\t0,1,3,2,7,6,4,5,15,14,12,13,8,9,11,10grayEnd:reset:\tldi   r16, low(RAMEND)\t\t;ALL assembly code should start by\tout   spl,r16\t\t\t\t      ; setting the Stack Pointer to\tldi   r16, high(RAMEND)\t\t; the end of SRAM to support\tout   sph,r16\t\t\t\t      ; function calls, etc.\tldi   xl,low(grayStart&lt;&lt;1)\t;position X and Y pointers to the\tldi   xh,high(grayStart&lt;&lt;1)\t;start and end addresses of\tldi   yl,low(grayEnd&lt;&lt;1)   ; our data table, respectively\tldi   yh,high(grayEnd&lt;&lt;1)\tmovw  z,x\t                 ;start Z pointer off at the start address of the table.\tldi r16,0x1E\tout DDRD,r16\t\t\t\tldi r16,0x07\tout DDRB,r16\t\t\t;pins to control transistors\tldi r16,0x0F\tout DDRC,r16\t\t\t;pins to control 7-segment driver    collect:\tclr r16\tclr r17\tclr r18\tin r16,PIND\t\t\t;store input from rotary encoder\tlsr r16\t\t\t    ;shift right to get gray code\tmovw z,r16\t\t\t;move to element the gray code is in binary\tadd zl,xl\tlpm r18,z\t\t\t  ;store fetched binary valueconvert:\tmov r16,r18\tldi iterate, 8\tldi three, 0x03\tldi threeTens, 0x30\tclr r17\tclr r18loop:   rol r16   rol r17   rol r18\t\t\t\t;shift value and BCD registers with carry   dec iterate\t\t\t   breq pov\t\t\t\t;jump to POV if there are no bits left to convert   mov temp, r17\t\t\t\t\t   andi temp, 0x0F\t\t\t\t\t   cpi temp, 0x05\t\t\t   brlo tens        ;skip to tens if value is less than 5\t\t   add r17,three    ;otherwise add threetens:   cpi temp, 0x50\t\t\t   brlo hundreds   add r17,threeTenshundreds:   andi temp, 0x0F   cpi temp, 0x50\t\t\t   brlo loop   add r18, threerjmp looppov:\tout PORTC,r18\t\t\t;output hundreds value\tldi r16,0x04\tout PORTB,r16\t\t\t;enable hundreds 7-seg disp\trcall delay\tlsr r16\tswap r17\tout PORTC,r17\t\t\t;output tens value\tout PORTB,r16\t\t\t;enable tens 7-seg disp\trcall delay\tlsr r16\tswap r17\tout PORTC,r17\t\t\t;output ones value\tout PORTB,r16\t\t\t;enable ones 7-seg disp\trcall delayrjmp collectdelay:; Generated by delay loop calculator; at http://www.bretmulvey.com/avrdelay.html;; Delay 16 000 cycles; 1ms at 16 MHz    ldi  r19, 21    ldi  r20, 199L1: dec  r20    brne L1    dec  r19    brne L1retConclusionTo conclude, I am satisfied with the final result of this project. Unfortunately, I was not able to have operational code by the end of the challenge period. After working on my program throughout the week, however, I was able to get a working solution. My initial code was organized properly, but not operational. This challenge has adequately tested my knowledge of assembly code. It has also helped me develop my understanding of Gray code and a broader understanding on conversion algorithms/techniques.ReferenceD’Arcy, Chris. “TEI4M Challenges.” ACES, RSGC, 15 Jan. 2018, darcy.rsgc.on.ca/ACES/TEI4M/1718/Challenges.html#2.Grayhill. “Series 25L.” Grayhill.com, Digi-Key, www.grayhill.com/assets/1/7/Mech_Encoder_25L.pdf.",
        "url": "//2018/01/20/Gray-Code-Challenge.html"
      }
      ,
    
      "2017-12-02-rotary-switch-monitor-html": {
        "title": "Challenge 2. Rotary Switch Monitor",
        "tags": "ER, ACES, Grade 12",
        "date": "December 2, 2017",
        "author": "",
        "category": "",
        "content": "PurposeThe purpose of this challenge is to create a circuit to light up a bicolour LED a specific colour depending on the position of a rotary decoder. The project works by reading the value of a  rotary encoder connected to an ATtiny85, then determining if said number has an odd or even number of set bits and displaying the appropriate colour on the LED. If the number of set bits is even, the LED will show red. Otherwise, it will be green. A resistor network provides appropriate pull down resistors for the input from the rotary encoder. The led should change colour immediately depending on the value of the rotary encoder.            Parts List                         ATtiny85      Red-Green BiColour LED              10 Position BCD Rotary DIP Switch      10k Ω Resistor Network (6-Pin Bussed)              Atmel ICE AVR Debugger      ATtiny85 ISP Breakout      ProcedureThis challenge started with reading the datasheet for the rotary encoder and wiring the circuit accordingly. Positive voltage connected to the common pin and the binary outputs connected to the resistor network. The resistor network provides a pull down resistance for the outputs of the rotary encoder. These outputs also connected to the input pins of the ATtiny85. Pin 1 connected to PORTB0, 2 to PORTB1 and 4 to PORTB2. This meant that the first 3 bits of PORTB represented the same value as shown on the rotary encoder. At right is the pinout of said rotary encoder. A bicolour LED is also connected to the ATtiny85 on pins PORTB3 and PORTB4, where the longer lead is in PORTB3.The next step was programming the ATtiny85 to read the binary value presented on its pins, determine the number of set bits, and display the appropriate LED colour. The program first enables output on PORTB pins 2 and 3 in the start label. Next, the microcontroller imports the high/low values on PORTB to a register using the in instruction. An andi instruction strips the highest 4 bits from this value and each bit is then tested to be either a one or a zero. If the bit is a one, the value on a separate register increases by one. If bit zero of this external register is a zero, the number of set bits is even, and the program jumps to the isEven label. This label calls the green function, and then returns to the load label to ensure constant monitoring of the rotary encoder value. If said value is odd, the same occurs but with the isOdd label and red function.Media                                      3D Render of circuit    Photo of circuit                                        Rotary encoder used in circuit    Fritzing Diagram        Link to YouTube Video: https://youtu.be/-HsjXjVvNDY  Code; Challenge 1.asm; Created: 2017-12-01 1:58:44 PM; Author : Ethan McAuliffe#define TEST_BIT 0b00001111; Replace with your application codestart:\tldi r16,0x18\tout 0x17,r16\tclr r16load:\tclr r16\tin r16,0x16again:\tandi r16,0x0F\tmov r18,r16\t\t;copy\tldi r17,11\t\t;mask\tand r18,r17\t\t;test\tsbrc r18,0\tinc r19\tasr r16\tbrne againsbrc r19, 0rjmp isOddrjmp isEvenisOdd:\trcall red\trjmp loadisEven:\trcall green\trjmp loadgreen:\tldi r16,0x10\tout 0x18,r16\tretred:\tldi r16,0x08\tout 0x18,r16\tretConclusionTo conclude, I am somewhat disappointed with the result of this project. While I was able to complete the code for the project in the allotted time, I did not get as many photos as I should and was not able to record any video of its operation. While my 3D render animation is effective at displaying what a similar circuit would look like, I would rather have video that I could use to explain the fundamental workings of my project. Furthermore, my code has switched up the colour of the LED to be displayed; when the number of set bits are even, my code sets the LED green LED instead of red. I did, however, find the challenge to be quite enjoyable. I liked being pushed to delve deep into the ATtiny85 datasheet and AVR instruction set. I do believe that I learned a lot from the completion of this challenge.ReferenceAtmel Corporation. Atmel ATtiny25, ATtiny45, ATtiny85 Datasheet. Aug. 2013, www.atmel.com/images/atmel-2586-avr-8-bit-microcontroller-attiny25-attiny45-attiny85_datasheet.pdf.Wurth Electronics Inc. “428527420910 Drawing.” Digi-Key, 25 July 2014, katalog.we-online.de/em/datasheet/428527420910.pdf.",
        "url": "//2017/12/02/Rotary-switch-monitor.html"
      }
      ,
    
      "2017-11-05-short-isp-html": {
        "title": "Short ISP:Relay Logic Adder",
        "tags": "ER, ACES, Grade 12",
        "date": "November 5, 2017",
        "author": "",
        "category": "",
        "content": "PurposeThe purpose of this project is to gain a better understanding of how relays work and how early computer logic was able to use relays before the invention of transistors. The end product also aims to be simple and easy to operate for potential students and their parents touring the Design Engineering Studio (DES). Finally, the end product aims to sound pleasing to the ear by performing a series of satisfying mechanical clicks when operated.The adder is to combine the sum of nine inputs, each of which being a power of two, into a binary output. The maximum sum value is 31. The calculator is capable of producing a possible 32 (25) unique sums (where zero is an acceptable sum). Each switch will add either a 2, 4, 6 or 8 to the total.            Parts List                         4× Full Adder Custom PCB      5× DC Power Jack              9× SPDT Toggle Switch      4× DC Barrel Plug              20W (5V@4A) Power Supply      5× 10mm Red LED              80× DPDT 5V 2A DC Relay      Grey PLA 3D Printer Filament              6.5” of 1”×1” Square Acrylic tubing      Clear Acrylic Sheet              24× Male/Female Pin Headers      Plywood Board      ProcedureThis project started with choosing relays to be a component in the project through a class Yankee Swap. The planning and idea brainstorming came after choosing relays to be a main component. After researching historic use of relays as logic capable devices, the chosen project would be a modular full adder circuit.Testing and research on creating logic gates with relays, specifically the NAND logic gate, proceeded the planned idea. NAND gates are important for logic operations as they can create any of the other logic gates when organized in specific ways. This testing and planning is similar to Project 2. Digital (Transistor-Based) Logic Gates, but with relays instead of transistors.The next step was creating a half adder with NAND logic using relays. The half adder is a circuit which takes two separate inputs and returns a sum, in binary, of those outputs on two pins, the SUM (Σ) and CARRY OUT pins. For example, if both outputs are high, the sum is a decimal two, represented by a low output on the Σ pin (as there are zero groups of 20) and a high output on the CARRY OUT pin (as there is one group of 21). After testing this circuit and reproducing it in EAGLE, the circuit needed further modifications to transform it into a full adder. Accomplishing this consists of chaining two half adder circuits together and performing a logical OR on the two CARRY OUT pins. The chaining of half adders works by connecting the Σ pin of the first half adder to an input on the second and adding a CARRY IN pin which connects to the second input of the second half adder. Now that a CARRY IN pin is present, the circuit is an operational full adder and it is possible to chain it with other identical full adders to work as a calculator (that only does addition).  The design and fabrication of a custom PCB followed the creation of a full adder circuit diagram in EAGLE (PCB shown right, link to schematic image: https://goo.gl/cXBRqa). The next step, after the arrival of the PCBs, was soldering the components to the board and testing operation. This includes soldering yellow relays in such a way that the four boards together spell out the word “ACES”.The next step was designing the LED holder (present below at right) and the clips used to mount the PCBs. Using Fusion 360 for design and the Ultimaker 3 for fabrication made this easy and efficient. This step included multiple iterations of the PCB clip design. The final product has an aesthetically pleasing symmetry, is easy to use and is strong.The next step is attaching the parts to the plywood board with the intention of making the final project both visually appealing and easy to use. This step consists of gluing the PCBs down using the custom designed clips and drilling holes through to the other side of the board to hide wires. It also includes soldering switches to power rails, chaining the CARRY OUT and CARRY IN pins of consecutive boards together, connecting the LEDs to the outputs of the full adder PCBs and labeling specific components for ease of use. The final step is connecting the full adder PCBs to the respective switch inputs. The project is now complete.Media                                      Circuit board render with clips    Yellow relays soldered on boards A &amp; C                                        Final Product    Output showing value of \"11\"        Link to YouTube Video: https://youtu.be/ibXhrRucC1A  ConclusionIn conclusion, I am happy with the result of this project. I enjoyed working with relays, despite them not being my initial choice in the Yankee Swap. This project had the unique benefit of being a mini history lesson too. I learned, through research online, how relays used to be found in nearly all electronics prior to the widespread use of vacuum tubes and transistors. Through this project I also learned why relays are never used in logic applications anymore: they use a lot of power, are very expensive and are at risk of mechanical failure. I am also happy with the appearance of my final project and am happy that it is going to be displayed in the lab for potential and younger students to get excited about electronics. While there are many skills that this project did not require (coding being the most significant), I still believe that this project was a resounding success.ReferenceLekule, Sostenes. “A Full-Adder.” LEKULE BLOG, 21 Apr. 2015, http://sosteneslekule.blogspot.ca/2015/04/a-full-adder.html.“Relay Logic Gates.” Electro-Tech-Online.com, http://www.electro-tech-online.com/attachments/upload_2015-6-18_21-28-8-png.92993/.",
        "url": "//2017/11/05/Short-ISP.html"
      }
      
    
  };
</script>

<script src="https://cdnjs.cloudflare.com/ajax/libs/lunr.js/0.7.1/lunr.min.js"></script>
<script src="/assets/js/search.js"></script>
</section>
</article>

    </div>
    
<script src="/assets/js/katex_init.js"></script>




  </body>
</html>
